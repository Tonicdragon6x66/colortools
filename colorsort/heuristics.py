import cv2
import numpy as np


def get_sample(image: np.array) -> np.array:
    """Get a sample of pixels from an image.

    Gets data from rule of thirds lines and quadrant lines.

    Args:
        image (np.array): The image from which to pull the sample.

    Returns:
        np.array: A sample of pixels from the provided image.
    """
    rot_sample = get_rule_of_thirds_sample(image)
    quad_sample = get_quadrant_sample(image)
    return np.concatenate((rot_sample, quad_sample))


def get_rule_of_thirds_sample(image: np.array) -> np.array:
    """Get a sample of pixels from an image using the "rule of thirds" lines.

    Args:
        image (np.array): The image from which to pull the sample.

    Returns:
        np.array: A sample of pixels from the provided image.
    """
    height, width, _ = np.shape(image)
    h0 = int(height / 3)
    h1 = h0 * 2
    v0 = int(width / 3)
    v1 = v0 * 2

    horizontal_slices = np.array([image[h0], image[h1]]).reshape((width * 2), 3)
    vertical_slices = np.array([image[:, v0], image[:, v1]]).reshape((height * 2), 3)
    return np.concatenate((horizontal_slices, vertical_slices))


def get_quadrant_sample(image: np.array) -> np.array:
    """Get a sample of pixels from an image using quadrant lines

    Sample draws pixels along the lines that bisect the image horizontally and vertically.

    Args:
        image (np.array): The image from which to pull the sample.

    Returns:
        np.array: A sample of pixels from the provided image.
    """
    height, width, _ = np.shape(image)
    h = int(height / 2)
    v = int(width / 2)

    horizontal_slice = np.array([image[h]]).reshape(width, 3)
    vertical_slice = np.array([image[:, v]]).reshape(height, 3)
    return np.concatenate((horizontal_slice, vertical_slice))


def auto_k_hue(image: np.array) -> int:
    """Set `k` based on the number of hues present in the provided image.

    This heuristic sets `k` using the following steps:
    - determine the number of discrete hues that are present in the provided image
    - determine the percentage of hues (out of 180) represented in the provided image
    - multiply the percentage of hues that are represented by 6
    - return the maximum of the computed value and 2

    Args:
        image (np.array): The image to generate `k` for.

    Returns:
        int: The value of `k` generated by this heuristic.
    """
    hsvImage = cv2.cvtColor(image, cv2.COLOR_RGB2HSV)
    reshaped = np.uint8(hsvImage.reshape((image.shape[0] * image.shape[1], 3)))

    hue_coverage = len(set([hsv[0] for hsv in reshaped])) / 180.0
    n_clusters = max(2, int(hue_coverage * 6))
    return n_clusters


def auto_k_hue_binned(image: np.array) -> int:
    """Set `k` based on the range of hues present in the provided image.

    This heuristic sets `k` using the following steps:
    - reduce the provided image to a long list of hues
    - sort the list of hues by color by distributing them into bins that are evenly spaced across the possible hue
    spectrum (i.e. [0, 30], [30, 60], ..., [150, 180])
    - determine which bin has most hues represented (which bin is the most full); set this to hue_bin_max
    - set `k` equal to the number of bins whose counts are within one standard deviation hue_bin_max

    Args:
        image (np.array): The image to generate `k` for.

    Returns:
        int: The value of `k` generated by this heuristic.
    """
    hsvImage = cv2.cvtColor(image, cv2.COLOR_RGB2HSV)
    reshaped = np.uint8(hsvImage.reshape((image.shape[0] * image.shape[1], 3)))
    hues = [hsv[0] for hsv in reshaped]

    hue_bins = {i: [] for i in range(6)}
    for h in hues:
        bin_number = int(h / 30)
        hue_bins[bin_number].append(h)

    bin_lengths = [len(binned_hues) for binned_hues in hue_bins.values()]
    hue_bin_max = np.max(bin_lengths)
    hue_bin_stdev = np.std(hues)

    n_clusters = 0
    for binned_hues in hue_bins.values():
        current_bin_length = len(binned_hues)
        if np.abs(current_bin_length - hue_bin_max) <= hue_bin_stdev:
            n_clusters += 1

    n_clusters = max(2, n_clusters)
    return n_clusters


def auto_k_binned_with_threshold(image: np.array, threshold: float = 0.1) -> int:
    """Set `k` based on the range of hues present in the provided image.

    This heuristic sets `k` using the following steps:
    - reduce the provided image to a long list of hues
    - sort the list of hues by color by distributing them into bins that are evenly spaced across the possible
    hue spectrum (i.e. [0, 30], [30, 60], ..., [150, 180])
    - determine which bin has most hues represented (which bin is the most full); set this to hue_bin_max
    - set `k` equal to the number of bins whose counts are at least at the threshold percentage of hue_bin_max
    (for instance, if the threshold is set to 0.1, then `k` is set to the number of bins whose counts are at
    least 10% of hue_bin_max)

    Args:
        image (np.array): The image to generate `k` for.
        threshold (float): The threshold for determining the bin count to use for `k`.

    Returns:
        int: The value of `k` generated by this heuristic.
    """
    hsvImage = cv2.cvtColor(image, cv2.COLOR_RGB2HSV)
    reshaped = np.uint8(hsvImage.reshape((image.shape[0] * image.shape[1], 3)))
    hues = [hsv[0] for hsv in reshaped]

    hue_bins = {i: [] for i in range(6)}
    for h in hues:
        bin_number = int(h / 30)
        hue_bins[bin_number].append(h)

    bin_lengths = [len(binned_hues) for binned_hues in hue_bins.values()]
    hue_bin_max = np.max(bin_lengths)
    hue_bin_max_10_percent = threshold * hue_bin_max

    n_clusters = 0
    for binned_hues in hue_bins.values():
        current_bin_length = len(binned_hues)
        if current_bin_length == hue_bin_max:
            n_clusters += 1
        elif current_bin_length > hue_bin_max_10_percent:
            n_clusters += 1

    n_clusters = max(2, n_clusters)
    return n_clusters


def auto_k_simple_threshold(image: np.array, threshold: float = 0.1) -> int:
    """Set `k` based on the range of hues present in the provided image.

    This heuristic sets `k` using the following steps:
    - reduce the provided image to a long list of hues
    - sort the list of hues by color by distributing them into bins that are evenly spaced across the possible
    hue spectrum (i.e. [0, 30], [30, 60], ..., [150, 180])
    - set `k` equal to the number of bins whose counts are at least at the threshold percentage of the total
    number of hues (for instance, if the threshold is set to 0.1, then `k` is set to the number of bins whose
    counts make up at least 10% of the total hue count)

    Args:
        image (np.array): The image to generate `k` for.
        threshold (float): The threshold for determining the bin count to use for `k`.

    Returns:
        int: The value of `k` generated by this heuristic.
    """
    hsvImage = cv2.cvtColor(image, cv2.COLOR_RGB2HSV)
    reshaped = np.uint8(hsvImage.reshape((image.shape[0] * image.shape[1], 3)))
    hues = [hsv[0] for hsv in reshaped]

    hue_bins = {i: [] for i in range(6)}
    for h in hues:
        bin_number = int(h / 30)
        hue_bins[bin_number].append(h)

    threhold_hue_count = threshold * len(hues)
    n_clusters = 0
    for binned_hues in hue_bins.values():
        current_bin_length = len(binned_hues)
        if current_bin_length >= threhold_hue_count:
            n_clusters += 1

    n_clusters = max(2, n_clusters)
    return n_clusters
