from enum import Enum
from typing import Callable

import cv2
import numpy as np


class HeuristicName(str, Enum):
    """Enum type for heuristic names."""

    AUTO_N_BINNED = "AUTO_N_BINNED"
    AUTO_N_HUE_BINNED = "AUTO_N_HUE_BINNED"
    AUTO_N_BINNED_WITH_THRESHOLD = "AUTO_N_BINNED_WITH_THRESHOLD"
    AUTO_N_SIMPLE_THRESHOLD = "AUTO_N_SIMPLE_THRESHOLD"


def get_heuristic(heuristic_name: HeuristicName) -> Callable:
    """Get the function that corresponds to a heuristic name.

    Args:
        heuristic_name (HeuristicName): The name of the heuristic to return.

    Raises:
        ValueError: Raised if the provided heuristic name is not recognized.

    Returns:
        Callable: The function corresponding to a heuristic name.
    """
    if heuristic_name == HeuristicName.AUTO_N_BINNED:
        return auto_n_hue_binned
    elif heuristic_name == HeuristicName.AUTO_N_HUE_BINNED:
        return auto_n_hue_binned
    elif heuristic_name == HeuristicName.AUTO_N_BINNED_WITH_THRESHOLD:
        return auto_n_binned_with_threshold
    elif heuristic_name == HeuristicName.AUTO_N_SIMPLE_THRESHOLD:
        return auto_n_simple_threshold
    else:
        raise ValueError(f"Invalid heuristic selected: {heuristic_name}")


def auto_n_hue(image_rgb: np.array) -> int:
    """Determine the number of clusters based on the number of hues present in the provided image.

    This heuristic determines `n` using the following steps:
    - determine the number of discrete hues that are present in the provided image
    - determine the percentage of hues (out of 180) represented in the provided image
    - multiply the percentage of hues that are represented by 6
    - return the maximum of the computed value and 2

    Args:
        image_rgb (np.array): The image to generate `n` for.

    Returns:
        int: The value of `n` (number of clusters) generated by this heuristic.
    """
    image_hsv = cv2.cvtColor(image_rgb, cv2.COLOR_RGB2HSV)
    reshaped = np.uint8(image_hsv.reshape((image_rgb.shape[0] * image_rgb.shape[1], 3)))

    hue_coverage = len(set([hsv[0] for hsv in reshaped])) / 180.0
    n_clusters = max(2, int(hue_coverage * 6))
    return n_clusters


def auto_n_hue_binned(image_rgb: np.array) -> int:
    """Determine the number of clusters based on the range of hues present in the provided image.

    This heuristic determines `n` using the following steps:
    - reduce the provided image to a long list of hues
    - sort the list of hues by color by distributing them into bins that are evenly spaced across the possible hue
    spectrum (i.e. [0, 30], [30, 60], ..., [150, 180])
    - determine which bin has most hues represented (which bin is the most full); set this to hue_bin_max
    - set `n` equal to the number of bins whose counts are within one standard deviation hue_bin_max

    Args:
        image_rgb (np.array): The image to generate `n` for.

    Returns:
        int: The value of `n` (number of clusters) generated by this heuristic.
    """
    image_hsv = cv2.cvtColor(image_rgb, cv2.COLOR_RGB2HSV)
    reshaped = np.uint8(image_hsv.reshape((image_rgb.shape[0] * image_rgb.shape[1], 3)))
    hues = [hsv[0] for hsv in reshaped]

    hue_bins = {i: [] for i in range(6)}
    for h in hues:
        bin_number = int(h / 30)
        hue_bins[bin_number].append(h)

    bin_lengths = [len(binned_hues) for binned_hues in hue_bins.values()]
    hue_bin_max = np.max(bin_lengths)
    hue_bin_stdev = np.std(hues)

    n_clusters = 0
    for binned_hues in hue_bins.values():
        current_bin_length = len(binned_hues)
        if np.abs(current_bin_length - hue_bin_max) <= hue_bin_stdev:
            n_clusters += 1

    n_clusters = max(2, n_clusters)
    return n_clusters


def auto_n_binned_with_threshold(image_rgb: np.array, threshold: float = 0.1) -> int:
    """Determine the number of clusters based on the range of hues present in the provided image.

    This heuristic determines `n` using the following steps:
    - reduce the provided image to a long list of hues
    - sort the list of hues by color by distributing them into bins that are evenly spaced across the possible
    hue spectrum (i.e. [0, 30], [30, 60], ..., [150, 180])
    - determine which bin has most hues represented (which bin is the most full); set this to hue_bin_max
    - set `n` equal to the number of bins whose counts are at least at the threshold percentage of hue_bin_max
    (for instance, if the threshold is set to 0.1, then `n` is set to the number of bins whose counts are at
    least 10% of hue_bin_max)

    Args:
        image_rgb (np.array): The image to generate `n` for.
        threshold (float): The threshold for determining the bin count to use for `n`.

    Returns:
        int: The value of `n` (number of clusters) generated by this heuristic.
    """
    image_hsv = cv2.cvtColor(image_rgb, cv2.COLOR_RGB2HSV)
    reshaped = np.uint8(image_hsv.reshape((image_rgb.shape[0] * image_rgb.shape[1], 3)))
    hues = [hsv[0] for hsv in reshaped]

    hue_bins = {i: [] for i in range(6)}
    for h in hues:
        bin_number = int(h / 30)
        hue_bins[bin_number].append(h)

    bin_lengths = [len(binned_hues) for binned_hues in hue_bins.values()]
    hue_bin_max = np.max(bin_lengths)
    hue_bin_max_10_percent = threshold * hue_bin_max

    n_clusters = 0
    for binned_hues in hue_bins.values():
        current_bin_length = len(binned_hues)
        if current_bin_length == hue_bin_max:
            n_clusters += 1
        elif current_bin_length > hue_bin_max_10_percent:
            n_clusters += 1

    n_clusters = max(2, n_clusters)
    return n_clusters


def auto_n_simple_threshold(image_rgb: np.array, threshold: float = 0.1) -> int:
    """Determine the number of clusters based on the range of hues present in the provided image.

    This heuristic sets `n` using the following steps:
    - reduce the provided image to a long list of hues
    - sort the list of hues by color by distributing them into bins that are evenly spaced across the possible
    hue spectrum (i.e. [0, 30], [30, 60], ..., [150, 180])
    - set `n` equal to the number of bins whose counts are at least at the threshold percentage of the total
    number of hues (for instance, if the threshold is set to 0.1, then `n` is set to the number of bins whose
    counts make up at least 10% of the total hue count)

    Args:
        image_rgb (np.array): The image to generate `n` for.
        threshold (float): The threshold for determining the bin count to use for `n`.

    Returns:
        int: The value of `n` (number of clusters) generated by this heuristic.
    """
    image_hsv = cv2.cvtColor(image_rgb, cv2.COLOR_RGB2HSV)
    reshaped = np.uint8(image_hsv.reshape((image_rgb.shape[0] * image_rgb.shape[1], 3)))
    hues = [hsv[0] for hsv in reshaped]

    hue_bins = {i: [] for i in range(6)}
    for h in hues:
        bin_number = int(h / 30)
        hue_bins[bin_number].append(h)

    threhold_hue_count = threshold * len(hues)
    n_clusters = 0
    for binned_hues in hue_bins.values():
        current_bin_length = len(binned_hues)
        if current_bin_length >= threhold_hue_count:
            n_clusters += 1

    n_clusters = max(2, n_clusters)
    return n_clusters
